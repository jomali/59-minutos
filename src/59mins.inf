!% -SD
!% +language_name=Spanish
!% $MAX_LABELS=2000
!% $MAX_ZCODE_SIZE=45000
!% $list


!!==============================================================================
!!
!!	59 MINUTOS
!!
!!==============================================================================
!!
!!	File:			59mins.inf
!!	Author(s):		J. Francisco Martín <jfm.lisaso@gmail.com>
!!	Languague:		ES (Castellano)
!!	System:			Inform-INFSP 6
!!	Platform:		Máquina-Z / GLULX
!!	Version:		0.1
!!	Released:		2014/03/05
!!
!!------------------------------------------------------------------------------
!!
!!	# HISTORIAL DE VERSIONES
!!
!!	0.1: 2014/03/05	Inicio del desarrollo.
!!
!!------------------------------------------------------------------------------
!!
!!	Este archivo forma parte de 59 MINUTOS.
!!
!!	59 MINUTOS es software libre: usted puede redistribuirlo y/o
!!	modificarlo bajo los términos de la Licencia Pública General GNU
!!	publicada por la Fundación para el Software Libre, ya sea la versión
!!	3 de la Licencia, o (a su elección) cualquier versión posterior.
!!
!!	59 MINUTOS se distribuye con la esperanza de que sea útil, pero
!!	SIN GARANTÍA ALGUNA; ni siquiera la garantía implícita MERCANTIL o
!!	de APTITUD PARA UN PROPÓSITO DETERMINADO. Consulte los detalles de
!!	la Licencia Pública General GNU para más información.
!!
!!	Debería haber recibido una copia de la Licencia Pública General GNU
!!	junto a 59 MINUTOS. En caso contrario, consulte
!!	<http://www.gnu.org/licenses/>.
!!
!!	Copyright (c) 2014, J. Francisco Martín
!!
!!------------------------------------------------------------------------------
!!
!!	# TABLA DE CONTENIDOS:
!!
!!	1)	Constantes y variables globales del relato.
!!	2)	Reemplazos de rutinas utilizadas por la librería Inform.
!!	3)	Librerías y extensiones (Parte 1 de 2).
!!	4)	Puntos de entrada para Glk (sólo en Glulx).
!!	5)	Librerías y extensiones (Parte 2 de 2).
!!	6)	Puntos de entrada.
!!	7)	Otras rutinas.
!!	8)	Gramática estándar y extendida.
!!	9)	Definición de atributos, clases y objetos.
!!
!!------------------------------------------------------------------------------
!!
!!	# TODO:
!!
!!	 -	En lugar de establecer un límite al máximo número de objetos que puede 
!!		llevar la protagonista en mano, sería interesante considerar el 
!!		inventario como un contenedor más, con límites de peso, tamaño,...
!!
!!------------------------------------------------------------------------------


!!==============================================================================
!!	1)	Constantes y variables globales del relato.
!!------------------------------------------------------------------------------

!! Información bibliográfica:

Constant Story "59 MINUTOS";
Constant Headline "Un relato interactivo de J. Francisco Martín, 2014";

Constant ALPHA_RELEASE;			! Fase de desarrollo ALFA
Constant Checking 1;			! Código de la versión del relato
Release 0; Serial "140311";		! 1.0 - 2014/03/11

!Constant BETA_RELEASE;			! Fase de desarrollo BETA
!Constant Checking 1;			! Código de la versión del relato
!Release 0; Serial "140311";	! 1.0 - 2014/03/11

!Constant DEMO_RELEASE;			! Versión de demostración
!Constant Checking 1;			! Código de la versión del relato
!Release 0; Serial "140311";	! 1.0 - 2014/03/11

!Constant FINAL_RELEASE;		! Versión publicable
!Constant Checking 1;			! Código de la versión del relato
!Release 0; Serial "140311";	! 1.0 - 2014/03/11

!! Constantes de la librería Inform:

Constant MANUAL_PRONOUNS;		! Los pronoms. refieren a objetos ya mencionados
Constant MAX_CARRIED 2;			! Máx. objetos que se pueden llevar en mano
Constant NO_PLACES;				! Acciones LUGARES y OBJETOS desactivadas
Constant NO_SCORE;				! No se lleva conteo de puntuación
Constant SACK_OBJECT X00_ropa;	! Contenedor principal para la librería
Constant SIN_MENSAJES;			! Se omiten los mensajes por defecto de la lib.

!! Constantes de la extensión types:

Constant PARSER_STYLE	_IST_;	! Selecciona estilo de los mensajes del parser
Constant PARSER_PREFIX	"[";	! Define texto inicial de los mens. del parser
Constant PARSER_SUFIX	"]";	! Define texto final de los mens. del parser

!! Constantes de la extensión topicInventory:

Constant TINV_STYLE		_IST_;	! Estilo de los mensajes
Constant TINV_PREFIX	"[";	! Texto inicial de los mensajes
Constant TINV_SUFIX		"]";	! Texto final de los menssajes
Constant TINV_MSG1		"";		! Texto del mensaje MSG1
Constant TINV_MSG2		"";		! Texto del mensaje MSG2
Constant TINV_COMMA		" / ";	! Separador del inventario de temas
Constant TINV_OR		" / ";	! Separador final del inventario de temas

!! Estilo de texto resaltado:

Global highlight_st = _IST_;	! Selecciona estilo de texto resaltado
Global highlight_flag = true;	! Indica si el estilo resaltado está activado

!! Otras constantes del relato:

!Constant NO_MULTIMEDIA;		! No se incluyen contenidos multimedia


!!==============================================================================
!!	2)	Reemplazos de rutinas utilizadas por la librería Inform.
!!------------------------------------------------------------------------------

Replace AttemptToTakeObject;	! Intento de transferir un objeto al jugador
Replace Banner;					! Créditos generales de la aplicación
Replace DrawStatusLine;			! Dibuja la barra de estado
Replace ExamineSub;				! Rutina para la acción ##Examine
Replace GetGNAOfObject;			! Rutina para obtener el GNA de un objeto
Replace InvSub;					! Rutinas para tomar INVENTARIO del personaje
Replace InvTallSub;				! Rutinas para tomar INVENTARIO del personaje
Replace InvWideSub;				! Rutinas para tomar INVENTARIO del personaje
Replace LMode1Sub;				! Lookmode 1: Breve
Replace LMode2Sub;				! Lookmode 2: Largo (establecido por defecto)
Replace LMode3Sub;				! Lookmode 3: Superbreve
Replace LookSub;				! Rutina para la acción ##Look
Replace PSN__;					! Rutina para imprimir nombre corto de un obj.
Replace VersionSub;				! Créditos detallados de la aplicación
Replace WearSub;				! Rutina para la acción ##Wear


!!==============================================================================
!!	3)	Librerías y extensiones (Parte 1 de 2).
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
#Ifndef NO_MULTIMEDIA;
Include "gwindefs.h";			! GWindows: Definiciones
#Endif; ! NO_MULTIMEDIA;
#Endif; ! TARGET_GLULX;

Include "Parser.h";				! Decodifica la entrada del teclado
Include "types.h";				! Rutinas para modificar estilo de los textos
Include ">59mins_lib.inf";		! Personalizaciones de la librería Inform
Include ">59mins_langLM.inf";	! Mensajes de la librería
Include ">59mins_langOM.inf";	! Mensajes de los objetos

#Ifdef TARGET_GLULX;
#Ifndef NO_MULTIMEDIA;
Include "gwincls.h";			! GWindows; Window Class Framework
#Endif; ! NO_MULTIMEDIA;
#Endif; ! TARGET_GLULX;


!!==============================================================================
!!	4)	Puntos de entrada para Glk (sólo en Glulx).
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
#Ifdef NO_MULTIMEDIA;

[ HandleGlkEvent ev context abortres
	i;
	!! Se gestiona el evento glk:
	switch (ev-->0) {
	0:	! evtype_None        - none
	1:	! evtype_Timer       - event repeated at fixed intervals
		AimingManager.run();
	2:	! evtype_CharInput   - keystroke input in a window
	3:	! evtype_LineInput   - full line of input in a window
	4:	! evtype_MouseInput  - mouse input in a window
	5:	! evtype_Arrange     - some windows sizes have changed
	6:	! evtype_Redraw      - graphic windows need redrawing
	7:	! evtype_SoundNotify - sound finished playing
	8:	! evtype_Hyperlink   - selection of a hyperlink in a window
		glk_request_hyperlink_event(gg_mainwin);
		glk_cancel_line_event(gg_mainwin, 0);
		write_text_buffer(ev-->2); ! ev--> 2 es el valor del enlace. Un obj.
		for (i = 0 : i <= text_buffer-->0 : i++) {
			abortres-->i = text_buffer-->i;
		}
		return 2;
	}
];

#Ifnot;

!!------------------------------------------------------------------------------
!!	Rutina gancho encargada de reinicializar Damusix y recuperar los canales de
!!	audio. (Sin esta rutina, al reiniciar la aplicación la música se solapará
!!	con aquella que se estuviese reproduciendo durante la partida anterior).
!!------------------------------------------------------------------------------
[ GWindowsGlkIdentify phase type ref rock;
	!! Se identifican todos los Objetos de Sonido gestionados por Damusix
	Damusix.IdentificarSonidos(phase);
	phase = type + ref + rock; ! (para evitar alertas del compilador)
];

!!------------------------------------------------------------------------------
!! Controlador de eventos Glk con la librería GWindows.
!!------------------------------------------------------------------------------
[ GWindowsGlkEvent ev context abortres
	i;
	!! Se notifica el efecto de fade de Tiempo Real
	Damusix.NotificarFade(ev);
	!! Se gestiona el evento glk:
	switch (ev-->0) {
	0:	! evtype_None        - none
	1:	! evtype_Timer       - event repeated at fixed intervals
		AimingManager.run();
	2:	! evtype_CharInput   - keystroke input in a window
	3:	! evtype_LineInput   - full line of input in a window
	4:	! evtype_MouseInput  - mouse input in a window
	5:	! evtype_Arrange     - some windows sizes have changed
	6:	! evtype_Redraw      - graphic windows need redrawing
	7:	! evtype_SoundNotify - sound finished playing
	8:	! evtype_Hyperlink   - selection of a hyperlink in a window
		glk_request_hyperlink_event(gg_mainwin);
		glk_cancel_line_event(gg_mainwin, 0);
		write_text_buffer(ev-->2); ! ev--> 2 es el valor del enlace. Un obj.
		for (i = 0 : i <= text_buffer-->0 : i++) {
			abortres-->i = text_buffer-->i;
		}
		return 2;
	}
	ev = context + abortres; ! (para evitar alertas del compilador)
];

#Endif; ! NO_MULTIMEDIA;
#Endif; ! TARGET_GLULX;


!!==============================================================================
!!	5)	Librerías y extensiones (Parte 2 de 2).
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
Include "infglk.h";				! Acceso sencillo a las funciones Glk
#Ifndef NO_MULTIMEDIA;
Include "damusix.h";			! Administrador unificado de sonido en Glulx
Include "gwindows.h";			! GWindows: Remplazos de la librería
Include ">59mins.bli";			! Recursos multimedia de la aplicación
Include ">59mins_gui.inf";		! Definición de la interfaz gráfica
#Endif; ! NO_MULTIMEDIA;
#Endif; ! TARGET_GLULX;

Include "aimAndFire.h";			! Sistema de apuntado y disparo QTE
Include "pPreprocessor.h";		! Preprocesador del analizador
Include "receptacles.h";		! Contenedores (con capacidad limitada)
Include "topicInventory.h";		! Sistema de conversación con inv. de temas

Include "VerbLib.h";			! Define cómo trabajan las acciones


!!==============================================================================
!!	6) Puntos de entrada.
!!------------------------------------------------------------------------------
!!	 -	BeforeParsing()
!!	 -	Initialise()
!!	 -	InScope()
!!	 -	PrintVerb()
!!	 -	UnknownVerb()
!!------------------------------------------------------------------------------

!!------------------------------------------------------------------------------
!! Permite manipular la entrada de usuario antes de que sea analizada por la 
!! librería. Es llamada después de que el sistema haya leído la entrada de 
!! texto y haya definido ya las tablas *buffer* y *parser*, pero aún no ha 
!! hecho nada más salvo establecer el contador de palabras *wn* a 1. La rutina 
!! puede manipular estas tablas libremente mientras permanezcan consistentes la 
!! una con la otra, y puede dejar el contador de palabras en cualquier punto. 
!! No retorna ningún valor.
!!------------------------------------------------------------------------------
[ BeforeParsing;
	ConversationManager.run();
	ParsingPreprocessor.run();
];

!!------------------------------------------------------------------------------
!! Inicialización del relato. Esta rutina es obligatoria y desempeña siempre 
!! una tarea obligatoria: establecer la localidad inicial del jugador (o el 
!! objeto accesible sobre o dentro el que empieza el jugador). Retorna *true* 
!! o *false* para continuar con la ejecución normal, o el valor 2 para suprimir 
!! la impresión de los créditos de la aplicación, que de otra manera se 
!! imprimirían inmediatamente después de llamar a la rutina.
!!------------------------------------------------------------------------------
[ Initialise;
	erase_window();				! Borra la ventana
	check_interpreter();		! Comprobaciones del intérprete
	lookmode = 2;				! Modo de las descripciones de localidad autom.

	ChangePlayer(X00_Silvia);	! Personaje controlado por el jugador
	SetGrammaticalInflection(THIRD_PERSON_PRESENT); ! Flexión gramatical lib.

	#Ifdef TARGET_GLULX;
	!! Establece la escucha de eventos glk para el uso de hiperenlaces:
	glk_request_hyperlink_event(gg_mainwin);
	#Ifndef NO_MULTIMEDIA;
	!! Oculta la ventana gráfica de la interfaz:
	HideGraphicWindow();
	!! Inicializa parámetros del gestor del sistema de apuntado:
	AimingManager.set_status_window(statusBar.winid);
	#Endif; ! NO_MULTIMEDIA;
	#Endif; ! TARGET_GLULX;

	!! Advertencia de la demostración:
	#Ifdef DEMO_RELEASE;
	print (strong) "ADVERTENCIA:", " Esta aplicación es una versión de
	demostración de un relato interactivo en estado de desarrollo. Los
	contenidos (en especial los textos) mostrados a continuación pueden no
	ajustarse necesariamente a los de la versión final.^";
	new_line;
	print (parser) "Pulsa una tecla para continuar.";
	press_any_key();
	erase_window();
	#Endif; ! DEMO_RELEASE;

	#Ifdef DEBUG;
	InitialiseDebug();
	#Ifnot; 
	main_menu();				! Menú principal. Establece la localidad inicial
	#Endif; ! DEBUG;

	return 2;
];

!! Inicializaciones del relato (en modo de depuración):
#Ifdef DEBUG;
[ InitialiseDebug;
	location = M07_PARQUE;
];
#Endif; ! DEBUG;

!!------------------------------------------------------------------------------
!! Foco del jugador. Ofrece una oportunidad para cambiar en el sistema la 
!! definición de lo que está al alcance del jugador. Utiliza las rutinas de la 
!! librería *ScopeWithin* y *PlaceInScope* para establecer cuál debería ser el 
!! foco. Retorna *false* para indicar al sistema que añada todos los objetos 
!! que suelen estar por defecto al alcance, o *true* para indicar que no se 
!! debe añadir nada más al foco. 
!!------------------------------------------------------------------------------
[ InScope person item;
	!! La localidad actual siempre está en el foco del jugador:
	PlaceInScope(real_location);
	!! En la oscuridad, se mueven al foco del jugador todos aquellos objetos
	!! que hayan sido ya manipulados previamente por el personaje:
	if ((person == player) && (location == thedark)) {
		objectloop(item in parent(player))
			if (item has moved) PlaceInScope(item);
	}
	return false;
];

!!------------------------------------------------------------------------------
!! Permite cambiar el verbo que imprime el sistema al hacer al usuario 
!! preguntas del tipo: "Intenta de nuevo porque sólo se pudo entender que 
!! quieres <lo que sea>.", en caso de que se haya definido algún verbo inusual 
!! por medio de la rutina *UnknownVerb(word)*. *word* es la dirección de 
!! diccionario del verbo. Retorna *true* para indicar al parser que se ha 
!! imprimido el verbo, o *false* para continuar con la ejecución normal y que 
!! el sistema imprima el verbo de la forma habitual.
!!------------------------------------------------------------------------------
[ PrintVerb word;
	if (word == 'no.verb' or 'teleport.verb') {
		print "hacer algo con";
		return true;
	}
	return false;
];

!!------------------------------------------------------------------------------
!! Invocada por el parser cuando se encuentra con un verbo desconocido, de 
!! forma que pueda cambiarse por uno definido en el relato. *word* es el valor 
!! de diccionario del verbo desconocido. Retorna *false* para permitir que el 
!! parser continúe con su ejecucción normal e imprima un mensaje de error, o un 
!! valor de diccionario del verbo a utilizar en lugar del verbo desconocido. Se 
!! utiliza para contemplar las siguientes situaciones:
!!
!! 1) Desplazarse automáticamente a una localidad adyacente a la localidad 
!! actual tecleando únicamente su nombre.
!!
!! 2) Lanzar una acción por defecto sobre un objeto cuando se teclea únicamente 
!! su nombre. En este caso se sigue la implementación propuesta en 
!! <http://rec.arts.int-fiction.narkive.com/Cz9j184N/inform-6-parser-question>
!! con modificaciones para que sólo se intente lanzar la acción sobre objetos 
!! que realmente existen y están presentes dentro del foco del jugador. De otra 
!! forma, siempre se intentaría lanzar la acción ##DefaultAction, aún cuando la 
!! intención del jugador no fuese manipular un objeto sino utilizar una acción 
!! que no está definida. (Tenemos que asegurarnos que la localidad actual se 
!! encuentra dentro del foco del jugador para que pueda referirse a ella. Ver 
!! rutina *InScope()*).
!!------------------------------------------------------------------------------
[ UnknownVerb
	obj;

	obj = ParsingPreprocessor.get_selected_object();
	if (obj ~= real_location && obj ofclass Room) {
		verb_wordnum = 0;
		return 'teleport.verb';
	}
	if (TestScope(obj, player)) {
		verb_wordnum = 0;
		return 'no.verb';
	}

	return false;
];


!!==============================================================================
!!	7) Otras rutinas.
!!------------------------------------------------------------------------------
!!	 -	check_interpreter()
!!	 -	erase_window()
!!	 -	highlight_style()
!!	 -	horizontal_rule()
!!	 -	link(obj)
!!	 -	main_menu()
!!	 -	press_any_key(delay:int)
!!	 -	read_object_name(obj)
!!	 -	top_holder(obj)
!!------------------------------------------------------------------------------

!!------------------------------------------------------------------------------
!! Comprueba las funcionalidades del intérprete.
!!------------------------------------------------------------------------------
[ check_interpreter;
	#Ifdef TARGET_GLULX;
	!! Comprobaciones de Tiempo Real:
	if (~~glk_gestalt(gestalt_Timer, 0)) {
		print (strong) "ERROR:", " Esta aplicación utiliza eventos de tiempo 
		real, pero tu intérprete GLULX no los soporta. Para ejecutar la 
		aplicación necesitarás un intérprete adecuado.^";
		new_line;
		print (parser) "Pulsa una tecla para salir.";
		press_any_key();
		quit;
	}
	#IfNdef NO_MULTIMEDIA;
	!! Comprobaciones de Gráficos y Audio:
	if (~~(glk_gestalt(gestalt_Sound, 0) && glk_gestalt(gestalt_SoundMusic, 0)
		&& glk_gestalt(gestalt_Graphics, 0))) {
		print (strong) "ADVERTENCIA:", " Esta aplicación incluye contenidos
		gráficos y de audio, pero tu intérprete GLULX no los soporta
		adecuadamente. El programa se iniciará con parte o la totalidad de sus
		recursos multimedia desactivados.^";
		new_line;
		print (parser) "Pulsa una tecla para continuar.";
		press_any_key();
		erase_window();
	}
	#Endif; ! NO_MULTIMEDIA;
	#Endif; ! TARGET_GLULX;
];

!!------------------------------------------------------------------------------
!! Deja la ventana en blanco.
!!------------------------------------------------------------------------------
[ erase_window;
    #Ifdef TARGET_ZCODE;
    @erase_window -1;
    #Ifnot; ! TARGET_GLULX
    if (gg_quotewin) {
		glk($0024, gg_quotewin, 0); ! close_window
		gg_quotewin = 0;
    }
    glk($002A, gg_mainwin); ! window_clear
    if (gg_statuswin) glk($002A, gg_statuswin); ! window_clear
    #Endif;
];

!!------------------------------------------------------------------------------
!! Inicia el estilo de texto resaltado.
!!------------------------------------------------------------------------------
[ highlight_style;
	if (highlight_flag) {
		switch (highlight_st) {
		_RST_:	roman_style();
		_IST_:	italic_style();
		_BST_:	bold_style();
		_MST_:	monospaced_style();
		}
	}
];

!!------------------------------------------------------------------------------
!! Imprime una regla horizontal centrada en pantalla.
!!------------------------------------------------------------------------------
[ horizontal_rule;
	monospaced_style();
	spaces (ScreenWidth()-1-7) / 2;
	print "*  *  *^";
	roman_style();
];

!!------------------------------------------------------------------------------
!! Imprime el nombre corto del objeto *obj* pasado como parámetro con estilo de 
!! texto resaltado, si es que el estilo resaltado está activado y el objeto 
!! cuenta con el atributo *remarkable*. En caso que se incluya una cadena de 
!! caracteres como segundo parámetro (es opcional), se imprime ésta en lugar 
!! del nombre corto del objeto. Además, sólo en GLULX, crea un hipervínculo 
!! asociado a este objeto *obj*.
!!
!! Si en lugar de un objeto se pasa una cadena de texto como parámetro *obj*, 
!! se imprime y, en GLULX, se crea un hipervínculo asociado a la cadena.
!!------------------------------------------------------------------------------
[ link obj text
	st;

	if (metaclass(obj) == String) {
		#Ifdef TARGET_GLULX;
		glk_set_hyperlink(obj);
		#Endif; ! TARGET_GLULX;
		print (string) obj;
		#Ifdef TARGET_GLULX;
		glk_set_hyperlink(0);
		#Endif; ! TARGET_GLULX;
		return true;
	}

	write_text_buffer(obj);
	if ((metaclass(obj) == Object)
		&& ((text_buffer-->0 ~= 4) || ~~(text_buffer->(0+WORDSIZE) == 'n' 
		&& text_buffer->(1+WORDSIZE) == 'a' && text_buffer->(2+WORDSIZE) == 'd'
		&& text_buffer->(3+WORDSIZE) == 'a'))) {
		#Ifdef TARGET_GLULX;
		glk_set_hyperlink(obj);
		#Endif; ! TARGET_GLULX;
		st = current_style;
		if (obj has remarkable) highlight_style();
		if (metaclass(text) == String) print (string) text;
		else print (name) obj;
		switch (st) {
			_RST_:	roman_style();
			_IST_:	italic_style();
			_BST_:	bold_style();
			_MST_:	monospaced_style();
		}
		#Ifdef TARGET_GLULX;
		glk_set_hyperlink(0);
		#Endif; ! TARGET_GLULX;
		return true;
	}
];

!!------------------------------------------------------------------------------
!! Menús (menú principal y menú con el índice de escenas).
!!------------------------------------------------------------------------------
[ main_menu i key;
	erase_window();
	Banner();
	new_line;
	horizontal_rule();
	new_line;
	monospaced_style();
	print "  Empezar la demostración  ";
		for (i=0 : i<(ScreenWidth() - 1 - 40) : i++) print ".";
		print "  [ESPACIO]  ^";
	print "  Recuperar partida guardada  ";
		for (i=0 : i<(ScreenWidth() - 1 - 43) : i++) print ".";
		print "      R      ^";
	print "  Salir de la aplicación  ";
		for (i=0 : i<(ScreenWidth() - 1 - 39) : i++) print ".";
		print "      Q      ^";
	roman_style();
	key = KeyCharPrimitive();

	location = H02_COCINA;		! Localidad inicial del relato

	switch (key) {
		'R', 'r': erase_window(); print "Cargando partida...^"; <<Restore>>;
		'Q', 'q': quit;
	}

	erase_window();
];

!!------------------------------------------------------------------------------
!! Espera una pulsación de tecla o, si se introduce un valor, a que pase una
!! cantidad delay de décimas de segundo antes de continuar. Retorna verdadero
!! si la tecla pulsada es 'q' o 'Q', falso en caso contrario.
!!------------------------------------------------------------------------------
[ press_any_key delay char;
	#Ifdef TARGET_GLULX;
	#Ifndef NO_MULTIMEDIA;
	if (Damusix.EnFade()) delay = 0;
	#Endif; ! NO_MULTIMEDIA;
	#Endif; ! TARGET_GLULX;
	if (delay > 0) char = KeyDelay(delay);
	else char = KeyCharPrimitive();
	if (char == 'q' or 'Q') return true;
	else return false;
];

!!------------------------------------------------------------------------------
!! Escribe una cadena de caracteres en un array. Se pueden pasar dos tipos de 
!! parámetros posibles: la propia cadena que se desea escribir, o la referencia 
!! a un objeto, en cuyo caso se escribe en el array el nombre de dicho objeto.
!!------------------------------------------------------------------------------
Constant TEXT_BUFFER_STREAM_ID = 666; ! Cualquier stream libre
Constant TEXT_BUFFER_SIZE = 64;
Array text_buffer --> TEXT_BUFFER_SIZE;

[ write_text_buffer param
	old_stream;
	!! Se comprueba que el parámetro sea válido:
	if (metaclass(param) ~= String && metaclass(param) ~= Object) return false;

	#Ifdef TARGET_ZCODE;
	old_stream = TEXT_BUFFER_STREAM_ID; ! por evitar advertencias del compilador
	!! Se cambia el flujo de salida a un array de memoria:
	@output_stream 3 text_buffer;
	!! Se escribe la cadena de texto en el array:
	if (metaclass(param) == String) print (string) param;
	else print (name) param;
	!! Se vuelve al flujo de salida original:
	@output_stream -3;
	#Ifnot; ! TARGET_GLULX;
	!! Se cambia el flujo de salida a un array de memoria:
	old_stream = glk_stream_get_current();
	glk_stream_set_current(glk_stream_open_memory(text_buffer + WORDSIZE, 
		TEXT_BUFFER_SIZE, filemode_Write, TEXT_BUFFER_STREAM_ID));
	!! Se escribe la cadena de texto en el array:
	if (metaclass(param) == String) print (string) param;
	else print (name) param;
	!! Se vuelve al flujo de salida original:
	glk_stream_close(glk_stream_get_current(), gg_arguments);
	glk_stream_set_current(old_stream);
	text_buffer --> 0 = gg_arguments --> 1;
	#Endif; ! TARGET_
];

!! Función para imprimir los contenidos del array *text_buffer*:
[ print_text_buffer
	tmp len;
	len = text_buffer --> 0;
	tmp = text_buffer + WORDSIZE;
	#Ifdef TARGET_ZCODE;
	@print_table tmp len;
	#Ifnot; ! TARGET_GLULX;
	glk_put_buffer(tmp, len);
	#Endif; ! TARGET_
];

!!------------------------------------------------------------------------------
!! TODO - revisar
!! Dado un objeto como parámetro, retorna su antecesor más lejano previo a los 
!! objetos localidad. (En el árbol de objetos del modelo de mundo, los objetos 
!! localidad ocupan el nivel 1 del árbol, mientras que el resultado de 
!! *top_holder()* ocuparía el nivel 2).
!!------------------------------------------------------------------------------
[ top_holder obj
	i;
	print "** top_holder de ", (name) obj, ": ";
	while (parent(obj) ~= 0) {
		i = ObjectScopedBySomething(obj);
		if (i == 0) i = parent(obj);
		if (parent(i) == 0) break;
		obj = i;
	}
	print (name) obj, ".^";
	return obj;
];


!!==============================================================================
!!	8)	Gramática estándar y extendida.
!!------------------------------------------------------------------------------
!!	Acciones añadidas o reemplazadas:
!!	 -	##Audio, ##AudioOn, ##AudioOff (sólo en GLULX)
!!	 -	##CloseX
!!	 -	##DefaultAction
!!	 -	##DisrobeX
!!	 -	##GNA (sólo en modo de depuración)
!!	 -	##Graphics, ##GraphicsOn, ##GraphicsOff (sólo en GLULX)
!!	 -	##Highlight
!!	 -	##LMode2
!!	 -	##NoSuchVerb (permite eliminar acciones)
!!	 -	##OpenX
!!	 -	##RemarkableObjects TODO - REVISAR
!!	 -	##TalkOn, ##TalkTo
!!	 -	##Teleport
!!	 -	##TopicInventory
!!	 -	##Wear
!!	 -	##WearX
!!
!!	Acciones eliminadas:
!!	 -	##Sorry
!!	 -	##Swim
!!------------------------------------------------------------------------------

Include	"SpanishG.h";		! Gramática española
Include	"SpanishEG.h";		! Gramática española extendida

!!------------------------------------------------------------------------------
!! ##Audio, ##AudioOn, ##AudioOff
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
#Ifndef NO_MULTIMEDIA;

Verb meta 'audio' 'music' 'musica' 'sonido' 'sonidos'
	*								-> Audio
	* 'on' / 'si'					-> AudioOn
	* 'encendido' / 'activado'		-> AudioOn
	* 'off' / 'no'					-> AudioOff
	* 'apagado' / 'desactivado'		-> AudioOff
;
VerboIrregular "establecer la reproducción de audio"
	with imperativo 'audio' 'music' 'musica' 'sonido' 'sonidos';

[ AudioSub;
	if (Damusix.HayAudio()) <<AudioOff>>;
	else <<AudioOn>>;
];

[ AudioOnSub;
	if (Damusix.HayAudio())
		print_ret (parser) "La reproducción de audio ya estaba activada.";
	Damusix.ActivarAudio();
	print_ret (parser) "Reproducción de audio activada.";
];

[ AudioOffSub;
	if (~~Damusix.HayAudio())
		print_ret (parser) "La reproducción de audio ya estaba desactivada.";
	Damusix.DesactivarAudio();
	print_ret (parser) "Reproducción de audio desactivada.";
];

#Endif; ! NO_MULTIMEDIA;
#Endif; ! TARGET_GLULX;

!!------------------------------------------------------------------------------
!! ##CloseX
!!------------------------------------------------------------------------------

Extend	only 'corre' replace
	* noun							-> CloseX
;

[ CloseXSub;
	print (parser) "En lugar de ~correr~ el objeto, se intenta utilizar
	la acción ~cerrar~, que en este contexto es sinónima, y es más general.
	(Apenas hay objetos corredizos en el mundo del relato, pero muchos se
	pueden abrir y cerrar.)";
	new_line; new_line;
	<<Close noun second>>;
];

!!------------------------------------------------------------------------------
!! ##DefaultAction
!!------------------------------------------------------------------------------

Verb 'no.verb'
	* noun							-> DefaultAction
;

[ DefaultActionSub;
	if (noun ofclass Room) <<Look>>;
	else <<Examine noun>>;
];

!!------------------------------------------------------------------------------
!! ##DisrobeX
!! Los verbos "desnudar"/"desvestir" pueden invocarse sin indicar un objeto, de
!! manera que un objeto "clothing" pueda capturar la acción ##DisrobeX en su
!! rutina "react_before" y lanzar la acción ##Disrobe sobre sí mismo.
!!------------------------------------------------------------------------------

Verb	'desnuda' 'desviste'
	*								-> DisrobeX
	* '-te'/'-me'					-> DisrobeX
	* noun							-> DisrobeX
	* '-te'/'-me' noun				-> DisrobeX
;
VerboIrregular "desvestir" with imperativo 'desnuda' 'desviste';

[ DisrobeXSub;
	if (noun == nothing)
		print_ret (parser) "Tienes que indicar qué quieres quitarte.";
	<<Disrobe noun>>;
];

!!------------------------------------------------------------------------------
!! ##GNA (sólo en modo de depuración)
!!------------------------------------------------------------------------------

#Ifdef	DEBUG;

Verb meta 'gna'
	* multi							-> GNA
;
VerboIrregular "determinar GNA" with imperativo 'gna';

[ GNA g;
	g = GetGNAOfObject(noun);
	print g, ": ";
	switch (g) {
		0,1,2,3,4,5: print "animado ";
		default:	 print "inanimado ";
	}
	switch (g) {
		0,1,2,6,7,8: print "singular ";
		default:	 print "plural ";
	}
	switch (g) {
		0,3,6,9:	 print "masculino";
		1,4,7,10:	 print "femenino";
		default:	 print "neutro";
	}
];

[ GNASub;
	start_parser_style();
	print "Objeto: ";
	roman_style();
	print (name) noun;
	parser_style();
	print ". (", (The) noun," / ", (the) noun," / ", (a) noun,
	" / -", (o) noun, ")^GNA ", (GNA) noun;
	end_parser_style();
	new_line;
];

#Endif; ! DEBUG;

!!------------------------------------------------------------------------------
!! ##Graphics, ##GraphicsOn, ##GraphicsOff
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
#Ifndef NO_MULTIMEDIA;

Verb meta 'grafico' 'graficos' 'graphic' 'graphics'
	*								-> Graphics
	* 'on'/'si'						-> GraphicsOn
	* 'encendido'/'activado'		-> GraphicsOn
	* 'encendidos'/'activados'		-> GraphicsOn
	* 'off'/'no'					-> GraphicsOff
	* 'apagado'/'desactivado'		-> GraphicsOff
	* 'apagados'/'desactivados'		-> GraphicsOff
;
VerboIrregular "establecer ventana gráfica"
	with imperativo 'grafico' 'graficos' 'graphic' 'graphics';

[ GraphicsSub;
	if (graphicWindow has on) <<GraphicsOff>>;
	else <<GraphicsOn>>;
];

[ GraphicsOnSub;
	if (graphicWindow has on)
		print_ret (parser) "La ventana gráfica ya estaba abierta.";
	if (GRAPHIC_WIN_WIDTH == 0 || graphicWindow.image == 0)
		print_ret (parser) "No hay gráficos que mostrar.";
	ShowGraphicWindow();
	print_ret (parser) "Ventana gráfica abierta.";
];

[ GraphicsOffSub;
	if (graphicWindow hasnt on)
		print_ret (parser) "La ventana gráfica ya estaba cerrada.";
	HideGraphicWindow();
	print_ret (parser) "Ventana gráfica cerrada.";
];

#Endif; ! NO_MULTIMEDIA;
#Endif; ! TARGET_GLULX;

!!------------------------------------------------------------------------------
!! ##Highlight
!!------------------------------------------------------------------------------

Verb meta 'highlight' 'resaltado'
	*								-> Highlight
	* number						-> Highlight
	* 'on'/'si'						-> HighlightOn
	* 'encendido'/'activado'		-> HighlightOn
	* 'off'/'no'					-> HighlightOff
	* 'apagado'/'desactivado'		-> HighlightOff
;
VerboIrregular "establecer estilo de texto resaltado"
	with imperativo 'highlight' 'resaltado';

[ HighlightSub;
	if (noun == nothing) {
		if (highlight_flag) <<HighlightOff>>;
		else <<HighlightOn>>;
	}
	switch (noun) {
		1:	highlight_st = _RST_;
			print_ret (parser) "Estilo de texto resaltado: ~romana~.";
		2:	highlight_st = _IST_;
			print_ret (parser) "Estilo de texto resaltado: ~itálica~.";
		3:	highlight_st = _BST_;
			print_ret (parser) "Estilo de texto resaltado: ~negrita~.";
		4:	highlight_st = _MST_;
			print_ret (parser) "Estilo de texto resaltado: ~monoespaciada~.";
		default:
			print_ret (parser) "El estilo de texto introducido no es válido. 
			Los estilos permitidos son: 1) romana, 2) itálica, 3) negrita y 4) 
			monoespaciada.";
	}
];

[ HighlightOnSub;
	if (highlight_flag)
		print_ret (parser) "El resaltado de objetos ya estaba activado.";
	highlight_flag = true;
	print_ret (parser) "Resaltado de objetos activado.";
];

[ HighlightOffSub;
	if (~~highlight_flag)
		print_ret (parser) "El resaltado de objetos ya estaba desactivado.";
	highlight_flag = false;
	print_ret (parser) "Resaltado de objetos desactivado.";
];

!!------------------------------------------------------------------------------
!! ##LMode2
!!------------------------------------------------------------------------------

Extend only 'normal' replace
    *								-> LMode2
;

!!------------------------------------------------------------------------------
!! ##NoSuchVerb
!! Permite eliminar acciones definidas automáticamente por la librería Inform.
!! Código extraído de <http://www.firthworks.com/roger/informfaq/vv.html#6>.
!!------------------------------------------------------------------------------

[ Anything; ! Se ignora el resto de la entrada de usuario
	while (NextWordStopped() ~= -1);
	return GPR_PREPOSITION;
];

Extend	'perdona' replace
	* Anything						-> NoSuchVerb
;

Extend	'nada' replace
	* Anything						-> NoSuchVerb
;

[ NoSuchVerbSub; return ParserError(VERB_PE); ];

!!------------------------------------------------------------------------------
!! ##OpenX
!!------------------------------------------------------------------------------

Verb	'descorre'
	* noun							-> OpenX
;

[ OpenXSub;
	print (parser) "En lugar de ~descorrer~ el objeto, se intenta utilizar
	la acción ~abrir~, que en este contexto es sinónima, y es más general.
	(Apenas hay objetos corredizos en el mundo del relato, pero muchos se
	pueden abrir y cerrar.)";
	new_line; new_line;
	<<Open noun second>>;
];

!!------------------------------------------------------------------------------
!! ##RemarkableObjects
!!------------------------------------------------------------------------------

Verb	meta 'objetos' 'objs'
	*								-> RemarkableObjects
;
VerboIrregular "mostrar objetos clave" with imperativo 'objetos' 'objs';

Global remarkableObjectsCount;

[ CountRemarkableObjects obj;
	if (obj has remarkable && ~~(obj ofclass Room))
		remarkableObjectsCount++;
];

[ PrintRemarkableObjects obj;
	if (obj has remarkable) {
		PronounNotice(obj);
		print " ", (the) obj;
		remarkableObjectsCount--;
		if (remarkableObjectsCount > 1) print ",";
		else if (remarkableObjectsCount == 1) print " y";
	}
];

[ RemarkableObjectsSub;
	remarkableObjectsCount = 0;
	LoopOverScope(CountRemarkableObjects);
	if (remarkableObjectsCount == 0)
		print_ret (parser) "No hay objetos destacables con los que puedas
		interactuar.";
	start_parser_style();
	print "Puedes interactuar con";
	LoopOverScope(PrintRemarkableObjects);
	print ".";
	end_parser_style();
	new_line;
	return true;
];

!!------------------------------------------------------------------------------
!! ##Remember - TODO
!!------------------------------------------------------------------------------

Verb	'evoca' 'recuerda'
	*								-> Remember
	* noun							-> Remember
;
VerboIrregular "recordar" with imperativo 'recuerda';

Verb	'cavila'
	*								-> Remember
	* noun							-> Remember
	* 'acerca' 'de' noun			-> Remember
	* 'sobre' noun					-> Remember
;

[ RememberSub;
	if (noun == nothing) {
		"No tiene nada que recordar.";
	}
	if (~~(noun ofclass Memory)) {
		"No tiene nada que recordar sobre ", (the) noun, ".";
	}
	"Piensa en ", (the) noun, ".";
];

!!------------------------------------------------------------------------------
!! ##TalkOn, ##TalkTo
!!------------------------------------------------------------------------------

Extend	'habla' replace
	* noun							-> TalkTo
	* 'a'/'con' noun				-> TalkTo
	* creature						-> TalkTo
	* 'a'/'con' creature			-> TalkTo
	* 'por' noun					-> TalkOn
	* 'por' creature				-> TalkOn
;

Verb	'conversa' 'platica'
	* noun							-> TalkTo
	* 'a'/'con' noun				-> TalkTo
	* creature						-> TalkTo
	* 'a'/'con' creature			-> TalkTo
	* 'por' noun					-> TalkOn
	* 'por' creature				-> TalkOn
;

[ TalkOnSub;
	start_parser_style();
	print "Habla con ", (name) noun;
	end_parser_style();
	new_line;
	<<TalkTo noun second>>;
];

[ TalkToSub;
	if ( noun == player ) {
		switch (GRAMMATICAL_INFLECTION) {
		1,2,3:	"Hablar con uno mismo no resulta especialmente divertido.";
		4,5,6:	"Hablar con uno mismo no resultaba especialmente divertido.";
		}
	}
	if ( noun hasnt animate )
		switch (GRAMMATICAL_INFLECTION) {
		1,2,3:	"Mejor intentar hablar con cosas que puedan devolver
				una respuesta.";
		4,5,6:	"Mejor intentar hablar con cosas que pudiesen devolver
				una respuesta.";
	}
	switch (GRAMMATICAL_INFLECTION) {
	1:	print_ret (The) noun, " no parece", (n) noun, " estar interesad",
		(o) noun, " en hablar conmigo.";
	2:	print_ret (The) noun, " no parece", (n) noun, " estar interesad",
		(o) noun, " en hablar contigo.";
	3:	print (The) noun, " no parece", (n) noun, " estar interesad",
		(o) noun, " en hablar con ";
		if (player has female ||
			(player provides gender && player.gender == G_FEMENINO))
			print "ella";
		else
			print "él";
		".";
	4:	print_ret (The) noun, " no parecía", (n) noun, " estar interesad",
		(o) noun, " en hablar conmigo.";
	5:	print_ret (The) noun, " no parecía", (n) noun, " estar interesad",
		(o) noun, " en hablar contigo.";
	6:	print (The) noun, " no parecía", (n) noun, " estar interesad",
		(o) noun, " en hablar con ";
		if (player has female ||
			(player provides gender && player.gender == G_FEMENINO))
			print "ella";
		else
			print "él";
		".";
	}
];

!!------------------------------------------------------------------------------
!! ##Teleport
!!------------------------------------------------------------------------------

[ TeleportScope obj adjacent_location;
	switch (scope_stage) {
		1:	return false;
		2:	objectloop (obj in Compass) {
				adjacent_location = real_location.(obj.door_dir);
				if (adjacent_location ~= 0)
					PlaceInScope(adjacent_location);
			}
			return true;
		3:	print_ret (parser) "No puedes llegar hasta ahí desde donde estás en 
			estos momentos.";
	}
];

Extend 've' last
	* scope=TeleportScope			-> Teleport
	* 'a//' scope=TeleportScope		-> Teleport
	* 'hacia' scope=TeleportScope	-> Teleport
;

Extend 'entra' last
	* scope=TeleportScope			-> Teleport
	* 'a//' scope=TeleportScope		-> Teleport
	* 'en' scope=TeleportScope		-> Teleport
;

Verb 'teleport.verb'
	* scope=TeleportScope			-> Teleport
;

[ TeleportSub;
	PlayerTo(noun, 2);
];

!!------------------------------------------------------------------------------
!! ##TopicInventory
!!------------------------------------------------------------------------------

Verb	meta 'temas' 't//'
	*								-> TopicInventory
; 
VerboIrregular "mostrar inventario de temas" with imperativo 'temas' 't//';

[ TopicInventorySub;
	if (~~(ConversationManager.is_running()))
		print_ret (parser) "No hay conversaciones activas en este momento.";
	ConversationManager.show_topic_inventory(true);
];


!!------------------------------------------------------------------------------
!! ##Wear
!! Basada en la implementación de *verblibm.h*. Si el objeto no está en
!! posesión del jugador, se le intenta pasar a su inventario automáticamente.
!!------------------------------------------------------------------------------

Extend	'ponte' replace
	* noun							-> Wear
	* 'con' noun					-> Wear
;

[ WearSub;
	if (ObjectIsUntouchable(noun)) return;
	if (noun hasnt clothing)    return L__M(##Wear, 1, noun);
	if (parent(noun) ~= player)
		if (AttemptToTakeObject(noun))
			return true;
	if (noun has worn)          return L__M(##Wear, 3, noun);
	give noun worn;
	if (AfterRoutines() == 1) rtrue;
	if (keep_silent == 1) rtrue;
	L__M(##Wear, 4, noun);
];

!!------------------------------------------------------------------------------
!! ##WearX
!! El verbo "vestir" ('vistete', 'vestirse', 'vestirte'...) puede invocarse sin
!! indicar un objeto, de manera que un objeto "clothing" pueda capturar la
!! acción ##WearX en su rutina "react_before" y lanzar la acción ##Wear sobre
!! sí mismo.
!!------------------------------------------------------------------------------

Extend	only 'vistete' 'vestirse' 'vestirte' 'vestirme' 'visteme' replace
	*								-> WearX
	* noun							-> WearX
	* 'con' noun					-> WearX
;
VerboIrregular "vestir" with imperativo
	'vistete' 'vestirse' 'vestirte' 'vestirme' 'visteme';

[ WearXSub;
	if (noun == nothing)
		print_ret (parser) "Tienes que indicar con qué quieres vestirte.";
	<<Wear noun>>;
];


!!==============================================================================
!!	9)	Definición de atributos, clases y objetos.
!!------------------------------------------------------------------------------

Include ">59mins_classes.inf";
Include ">59mins_objects.inf";
Include ">59mins_memory1.inf";
Include ">59mins_memory2.inf";
Include ">59mins_memory3.inf";
Include ">59mins_memory4.inf";
Include ">59mins_memory5.inf";
Include ">59mins_memory6.inf";
Include ">59mins_memory7.inf";
Include ">59mins_memory8.inf";


