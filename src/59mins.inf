!% -SD
!% +language_name=Spanish
!% $MAX_LABELS=2000
!% $MAX_ZCODE_SIZE=45000
!% $list


!!==============================================================================
!!
!!	59 MINUTOS
!!
!!==============================================================================
!!
!!	File:			59mins.inf
!!	Author(s):		J. Francisco Martín <jfm.lisaso@gmail.com>
!!	Languague:		ES (Castellano)
!!	System:			Inform-INFSP 6
!!	Platform:		Máquina-Z / GLULX
!!	Version:		0.1
!!	Released:		2014/03/05
!!
!!------------------------------------------------------------------------------
!!
!!	Este archivo forma parte de 59 MINUTOS.
!!
!!	59 MINUTOS es software libre: usted puede redistribuirlo y/o
!!	modificarlo bajo los términos de la Licencia Pública General GNU
!!	publicada por la Fundación para el Software Libre, ya sea la versión
!!	3 de la Licencia, o (a su elección) cualquier versión posterior.
!!
!!	59 MINUTOS se distribuye con la esperanza de que sea útil, pero
!!	SIN GARANTÍA ALGUNA; ni siquiera la garantía implícita MERCANTIL o
!!	de APTITUD PARA UN PROPÓSITO DETERMINADO. Consulte los detalles de
!!	la Licencia Pública General GNU para más información.
!!
!!	Debería haber recibido una copia de la Licencia Pública General GNU
!!	junto a 59 MINUTOS. En caso contrario, consulte
!!	<http://www.gnu.org/licenses/>.
!!
!!	Copyright (c) 2014, J. Francisco Martín
!!
!!------------------------------------------------------------------------------


!!==============================================================================
!!	Constantes y variables globales del relato
!!------------------------------------------------------------------------------

Constant Story "59 MINUTOS";
Constant Headline "Un relato interactivo de J. Francisco Martín, 2014";

Constant ALPHA_RELEASE;			! Fase de desarrollo ALFA
Constant Checking 1;			! Código de la versión del relato
Release 0; Serial "140311";		! 1.0 - 2014/03/11

!Constant BETA_RELEASE;			! Fase de desarrollo BETA
!Constant Checking 1;			! Código de la versión del relato
!Release 0; Serial "140311";	! 1.0 - 2014/03/11

!Constant DEMO_RELEASE;			! Versión de demostración
!Constant Checking 1;			! Código de la versión del relato
!Release 0; Serial "140311";	! 1.0 - 2014/03/11

!Constant FINAL_RELEASE;		! Versión publicable
!Constant Checking 1;			! Código de la versión del relato
!Release 0; Serial "140311";	! 1.0 - 2014/03/11

!Constant NO_MULTIMEDIA;		! No se incluyen contenidos multimedia

!! TODO - en lugar de establecer un límite al máximo número de objetos que 
!! puede llevar el personaje en mano, sería interesante considerar el inv. del 
!! personaje como un contenedor más, con límites de peso, tamaño,... ¿Creando 
!! un objeto personaje e invocando a la rutina de cambio de personaje?

Constant MANUAL_PRONOUNS;		! Los pronoms. refieren a objetos ya mencionados
Constant MAX_CARRIED 2;			! Máx. objetos que se pueden llevar en mano
Constant NO_PLACES;				! Acciones LUGARES y OBJETOS desactivadas
Constant NO_SCORE;				! No se lleva conteo de puntuación
Constant SACK_OBJECT obj_ropa;	! Contenedor principal para la librería
Constant SIN_MENSAJES;			! Se omiten los mensajes por defecto de la lib.

Constant PARSER_STYLE _IST_;	! Selecciona estilo de los mensajes del parser
Constant PARSER_PREFIX "[";		! Define texto inicial de los mens. del parser
Constant PARSER_SUFIX "]";		! Define texto final de los mens. del parser

Global hyperlink_st = _BST_;	! Selecciona estilo de los hipervínculos


!!==============================================================================
!!	Reemplazos de rutinas utilizadas por la librería Inform
!!------------------------------------------------------------------------------

Replace AttemptToTakeObject;	! Intento de transferir un objeto al jugador
Replace Banner;					! Créditos generales de la aplicación
Replace DrawStatusLine;			! Dibuja la barra de estado
Replace ExamineSub;				! Rutina para la acción ##Examine
Replace GetGNAOfObject;			! Rutina para obtener el GNA de un objeto
Replace InvSub;					! Rutinas para tomar INVENTARIO del personaje
Replace InvTallSub;				! Rutinas para tomar INVENTARIO del personaje
Replace InvWideSub;				! Rutinas para tomar INVENTARIO del personaje
Replace LMode1Sub;				! Lookmode 1: Breve
Replace LMode2Sub;				! Lookmode 2: Largo (establecido por defecto)
Replace LMode3Sub;				! Lookmode 3: Superbreve
Replace LookSub;				! Rutina para la acción ##Look
Replace VersionSub;				! Créditos detallados de la aplicación
Replace WearSub;				! Rutina para la acción ##Wear


!!==============================================================================
!!	Librerías y extensiones (Parte 1 de 2)
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
#Ifndef NO_MULTIMEDIA;
Include "gwindefs.h";			! GWindows: Definiciones
#Endif; ! NO_MULTIMEDIA;
#Endif; ! TARGET_GLULX;

Include "Parser.h";				! Decodifica la entrada del teclado
Include ">59mins_lib.inf";		! Personalizaciones de la librería Inform
Include ">59mins_langLM.inf";	! Mensajes de la librería
Include ">59mins_langOM.inf";	! Mensajes de los objetos

Include ">makinaimo.inf";

#Ifdef TARGET_GLULX;
#Ifndef NO_MULTIMEDIA;
Include "gwincls.h";			! GWindows; Window Class Framework
#Endif; ! NO_MULTIMEDIA;
#Endif; ! TARGET_GLULX;


!!==============================================================================
!!	Puntos de entrada para Glk (sólo en Glulx)
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
#Ifdef NO_MULTIMEDIA;

[ HandleGlkEvent ev context abortres
	i;
	!! Se gestiona el evento glk:
	switch (ev-->0) {
	0:	! evtype_None        - none
	1:	! evtype_Timer       - event repeated at fixed intervals
		AimingManager.run();
	2:	! evtype_CharInput   - keystroke input in a window
	3:	! evtype_LineInput   - full line of input in a window
	4:	! evtype_MouseInput  - mouse input in a window
	5:	! evtype_Arrange     - some windows sizes have changed
	6:	! evtype_Redraw      - graphic windows need redrawing
	7:	! evtype_SoundNotify - sound finished playing
	8:	! evtype_Hyperlink   - selection of a hyperlink in a window
		glk_request_hyperlink_event(gg_mainwin);
		glk_cancel_line_event(gg_mainwin, 0);
		get_name_buffer(ev-->2); ! ev--> 2 es el valor del enlace. Un obj.
		for (i = 0 : i <= name_buffer-->0 : i++) {
			abortres-->i = name_buffer-->i;
		}
		return 2;
	}
];

#Ifnot;

!!------------------------------------------------------------------------------
!!	Rutina gancho encargada de reinicializar Damusix y recuperar los canales de
!!	audio. (Sin esta rutina, al reiniciar la aplicación la música se solapará
!!	con aquella que se estuviese reproduciendo durante la partida anterior).
!!------------------------------------------------------------------------------
[ GWindowsGlkIdentify phase type ref rock;
	!! Se identifican todos los Objetos de Sonido gestionados por Damusix
	Damusix.IdentificarSonidos(phase);
	phase = type + ref + rock; ! (para evitar alertas del compilador)
];

!!------------------------------------------------------------------------------
!! Controlador de eventos Glk con la librería GWindows.
!!------------------------------------------------------------------------------
[ GWindowsGlkEvent ev context abortres
	i;
	!! Se notifica el efecto de fade de Tiempo Real
	Damusix.NotificarFade(ev);
	!! Se gestiona el evento glk:
	switch (ev-->0) {
	0:	! evtype_None        - none
	1:	! evtype_Timer       - event repeated at fixed intervals
		AimingManager.run();
	2:	! evtype_CharInput   - keystroke input in a window
	3:	! evtype_LineInput   - full line of input in a window
	4:	! evtype_MouseInput  - mouse input in a window
	5:	! evtype_Arrange     - some windows sizes have changed
	6:	! evtype_Redraw      - graphic windows need redrawing
	7:	! evtype_SoundNotify - sound finished playing
	8:	! evtype_Hyperlink   - selection of a hyperlink in a window
		glk_request_hyperlink_event(gg_mainwin);
		glk_cancel_line_event(gg_mainwin, 0);
		get_name_buffer(ev-->2); ! ev--> 2 es el valor del enlace. Un obj.
		for (i = 0 : i <= name_buffer-->0 : i++) {
			abortres-->i = name_buffer-->i;
		}
		return 2;
	}
	ev = context + abortres; ! (para evitar alertas del compilador)
];

#Endif; ! NO_MULTIMEDIA;
#Endif; ! TARGET_GLULX;


!!==============================================================================
!!	Librerías y extensiones (Parte 2 de 2)
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
Include "infglk.h";				! Acceso sencillo a las funciones Glk
#Ifndef NO_MULTIMEDIA;
Include "damusix.h";			! Administrador unificado de sonido en Glulx
Include "gwindows.h";			! GWindows: Remplazos de la librería
Include ">59mins.bli";			! Recursos multimedia de la aplicación
Include ">59mins_gui.inf";		! Definición de la interfaz gráfica
#Endif; ! NO_MULTIMEDIA;
#Endif; ! TARGET_GLULX;

Include "aimAndFire.h";			! Sistema de apuntado y disparo QTE
Include "receptacles.h";		! Contenedores (con capacidad limitada)
Include "topicInventory.h";		! Sistema de conversación con inv. de temas
Include "types.h";				! Rutinas para modificar estilo de los textos

Include "VerbLib.h";			! Define cómo trabajan las acciones


!!==============================================================================
!!	Puntos de entrada
!!------------------------------------------------------------------------------

!!------------------------------------------------------------------------------
!! Permite manipular la entrada de usuario antes de que sea analizada por la 
!! librería. Es llamada después de que el sistema haya leído la entrada de 
!! texto y haya definido ya las tablas *buffer* y *parser*, pero aún no ha 
!! hecho nada más salvo establecer el contador de palabras *wn* a 1. La rutina 
!! puede manipular estas tablas libremente mientras permanezcan consistentes la 
!! una con la otra, y puede dejar el contador de palabras en cualquier punto. 
!! No retorna ningún valor.
!!------------------------------------------------------------------------------
[ BeforeParsing obj i;
	ConversationManager.run();
	ParsingPreprocessor.run();
];

!!------------------------------------------------------------------------------
!! Inicialización del relato. Esta rutina es obligatoria y desempeña siempre 
!! una tarea obligatoria: establecer la localidad inicial del jugador (o el 
!! objeto accesible sobre o dentro el que empieza el jugador). Retorna *true* 
!! o *false* para continuar con la ejecución normal, o el valor 2 para suprimir 
!! la impresión de los créditos de la aplicación, que de otra manera se 
!! imprimirían inmediatamente después de llamar a la rutina.
!!------------------------------------------------------------------------------
[ Initialise;
	erase_window();				! Borra la ventana
	check_interpreter();		! Comprobaciones del intérprete
	lookmode = 2;				! Modo de las descripciones de localidad autom.

	#Ifdef TARGET_GLULX;
	!! Establece la escucha de eventos glk para el uso de hiperenlaces:
	glk_request_hyperlink_event(gg_mainwin);
	#Ifndef NO_MULTIMEDIA;
	!! Oculta la ventana gráfica de la interfaz:
	HideGraphicWindow();
	!! Inicializa parámetros del gestor del sistema de apuntado:
	AimingManager.set_status_window(statusBar.winid);
	#Endif; ! NO_MULTIMEDIA;
	#Endif; ! TARGET_GLULX;

	!! Advertencia de la demostración:
	#Ifdef DEMO_RELEASE;
	print (strong) "ADVERTENCIA:", " Esta aplicación es una versión de
	demostración de un relato interactivo en estado de desarrollo. Los
	contenidos (en especial los textos) mostrados a continuación pueden no
	ajustarse necesariamente a los de la versión final.^";
	new_line;
	print (parser) "Pulsa una tecla para continuar.";
	press_any_key();
	erase_window();
	#Endif; ! DEMO_RELEASE;

	main_menu();				! Menú principal. Establece la localidad inicial

	return 2;
];

!! Inicializaciones del relato (en modo de depuración):
[ InitialiseDebug;
	#Ifdef DEBUG;
	move obj_pelotaBaloncesto to obj_Silvia;
	location = obj_TERRAZA;
	#Endif; ! DEBUG;
];

!!------------------------------------------------------------------------------
!! Foco del jugador. Ofrece una oportunidad para cambiar en el sistema la 
!! definición de lo que está al alcance del jugador. Utiliza las rutinas de la 
!! librería *ScopeWithin* y *PlaceInScope* para establecer cuál debería ser el 
!! foco. Retorna *false* para indicar al sistema que añada todos los objetos 
!! que suelen estar por defecto al alcance, o *true* para indicar que no se 
!! debe añadir nada más al foco. 
!!------------------------------------------------------------------------------
[ InScope person item;
	!! La localidad actual siempre está en el foco del jugador:
	PlaceInScope(real_location);
	!! En la oscuridad, se mueven al foco del jugador todos aquellos objetos
	!! que hayan sido ya manipulados previamente por el personaje:
	if ((person == player) && (location == thedark)) {
		objectloop(item in parent(player))
			if (item has moved) PlaceInScope(item);
	}
	return false;
];

!!------------------------------------------------------------------------------
!! Permite cambiar el verbo que imprime el sistema al hacer preguntas al 
!! jugador del tipo "¿Qué quieres <lo que sea>?", en caso de que se haya 
!! definido algún verbo inusual por medio de la rutina *UnknownVerb(word)*. 
!! *word* es la dirección de diccionario del verbo. Retorna *true* para indicar 
!! al parser que se ha imprimido el verbo, o *false* para continuar con la 
!! ejecucción normal y que el sistema imprima el verbo de la forma habitual.
!!------------------------------------------------------------------------------
[ PrintVerb word;
	if (word == 'no.verb') {
		print "hacer algo con";
		return true;
	}
	if (word == 'teleport.verb') {
		print "desplazarte a";
		return true;
	}
	return false;
];

!!------------------------------------------------------------------------------
!! Invocada por el parser cuando se encuentra con un verbo desconocido, de 
!! forma que pueda cambiarse por uno definido en el relato. *word* es el valor 
!! de diccionario del verbo desconocido. Retorna *false* para permitir que el 
!! parser continúe con su ejecucción normal e imprima un mensaje de error, o un 
!! valor de diccionario del verbo a utilizar en lugar del verbo desconocido. Se 
!! utiliza para contemplar las siguientes situaciones:
!!
!! 1) Desplazarse automáticamente a una localidad tecleando únicamente su 
!! nombre.
!!
!! 2) Lanzar una acción por defecto sobre un objeto cuando se teclea únicamente 
!! su nombre. En este caso se sigue la implementación propuesta en 
!! <http://rec.arts.int-fiction.narkive.com/Cz9j184N/inform-6-parser-question>
!! con modificaciones para que sólo se intente lanzar la acción sobre objetos 
!! que realmente existen y están presentes dentro del foco del jugador. De otra 
!! forma, siempre se intentaría lanzar la acción ##DefaultAction, aún cuando la 
!! intención del jugador no fuese manipular un objeto sino utilizar una acción 
!! que no está definida. (Tenemos que asegurarnos que la localidad actual se 
!! encuentra dentro del foco del jugador para que pueda referirse a ella. Ver 
!! rutina *InScope()*).
!!------------------------------------------------------------------------------
[ UnknownVerb word
	obj adjacent_location;
	objectloop (obj in Compass) {
		if (real_location.(obj.door_dir) 
		== ParsingPreprocessor.get_selected_object()) {
			verb_wordnum = 0;
			return 'teleport.verb';
		}
	}
	if (ParsingPreprocessor.get_selected_object() ~= 0) {
		verb_wordnum = 0;
		return 'no.verb';
	}

	return false;
];


!!==============================================================================
!!	Otras rutinas
!!------------------------------------------------------------------------------

!!------------------------------------------------------------------------------
!! Comprueba las funcionalidades del intérprete.
!!------------------------------------------------------------------------------
[ check_interpreter;
	#Ifdef TARGET_GLULX;
	!! Comprobaciones de Tiempo Real:
	if (~~glk_gestalt(gestalt_Timer, 0)) {
		print (strong) "ERROR:", " Esta aplicación utiliza eventos de tiempo 
		real, pero tu intérprete GLULX no los soporta. Para ejecutar la 
		aplicación necesitarás un intérprete adecuado.^";
		new_line;
		print (parser) "Pulsa una tecla para salir.";
		press_any_key();
		quit;
	}
	#IfNdef NO_MULTIMEDIA;
	!! Comprobaciones de Gráficos y Audio:
	if (~~(glk_gestalt(gestalt_Sound, 0) && glk_gestalt(gestalt_SoundMusic, 0)
		&& glk_gestalt(gestalt_Graphics, 0))) {
		print (strong) "ADVERTENCIA:", " Esta aplicación incluye contenidos
		gráficos y de audio, pero tu intérprete GLULX no los soporta
		adecuadamente. El programa se iniciará con parte o la totalidad de sus
		recursos multimedia desactivados.^";
		new_line;
		print (parser) "Pulsa una tecla para continuar.";
		press_any_key();
		erase_window();
	}
	#Endif; ! NO_MULTIMEDIA;
	#Endif; ! TARGET_GLULX;
];

!!------------------------------------------------------------------------------
!! Deja la ventana en blanco.
!!------------------------------------------------------------------------------
[ erase_window;
    #Ifdef TARGET_ZCODE;
    @erase_window -1;
    #Ifnot; ! TARGET_GLULX
    if (gg_quotewin) {
		glk($0024, gg_quotewin, 0); ! close_window
		gg_quotewin = 0;
    }
    glk($002A, gg_mainwin); ! window_clear
    if (gg_statuswin) glk($002A, gg_statuswin); ! window_clear
    #Endif;
];

!!------------------------------------------------------------------------------
!! Imprime una regla horizontal centrada en pantalla.
!!------------------------------------------------------------------------------
[ horizontal_rule;
	monospaced_style();
	spaces (ScreenWidth()-1-7) / 2;
	print "*  *  *^";
	roman_style();
];

!!------------------------------------------------------------------------------
!! Inicia estilo de texto de los hipervínculos.
!!------------------------------------------------------------------------------
[ hyperlink_style;
	switch (hyperlink_st) {
	_RST_:	roman_style();
	_IST_:	italic_style();
	_BST_:	bold_style();
	_MST_:	monospaced_style();
	}
];

!!------------------------------------------------------------------------------
!! Indica el punto de inicio/fin de un hipervínculo.
!!------------------------------------------------------------------------------
[ link obj;
	#Ifdef TARGET_GLULX;
	get_name_buffer(obj);
!	print "*";
!	for (obj=0 : obj < name_buffer-->0 : obj++) {
!		print (char) name_buffer->(obj+WORDSIZE);
!	}
!	print "*";
	if ((name_buffer-->0 ~= 4) || ~~(name_buffer->(0+WORDSIZE) == 'n' 
		&& name_buffer->(1+WORDSIZE) == 'a' && name_buffer->(2+WORDSIZE) == 'd'
		&& name_buffer->(3+WORDSIZE) == 'a')) {
		hyperlink_style();
		glk_set_hyperlink(obj);
!		print "*";
!		for (obj=0 : obj < name_buffer-->0 : obj++) {
!			print (char) name_buffer->(obj+WORDSIZE);
!		}
!		print "*";
	}
	else {
		roman_style();
		glk_set_hyperlink(0);
	}
	#Endif; !TARGET_GLULX;
];

!!------------------------------------------------------------------------------
!! Menús (menú principal y menú con el índice de escenas).
!!------------------------------------------------------------------------------
[ main_menu i key;
	erase_window();
	Banner();
	new_line;
	horizontal_rule();
	new_line;
	monospaced_style();
	print "  Empezar la demostración  ";
		for (i=0 : i<(ScreenWidth() - 1 - 40) : i++) print ".";
		print "  [ESPACIO]  ^";
	print "  Recuperar partida guardada  ";
		for (i=0 : i<(ScreenWidth() - 1 - 43) : i++) print ".";
		print "      R      ^";
	print "  Salir de la aplicación  ";
		for (i=0 : i<(ScreenWidth() - 1 - 39) : i++) print ".";
		print "      Q      ^";
	roman_style();
	key = KeyCharPrimitive();

	ChangePlayer(obj_Silvia);	! Personaje controlado por el jugador
	SetGrammaticalInflection(THIRD_PERSON_PRESENT); ! Flexión gramatical lib.
	location = obj_COCINA;		! Localidad inicial del relato

	#Ifdef DEBUG;
	InitialiseDebug();
	#Endif; ! DEBUG;

	switch (key) {
		'R', 'r': erase_window(); print "Cargando partida...^"; <<Restore>>;
		'Q', 'q': quit;
	}

	erase_window();
];

!!------------------------------------------------------------------------------
!! Espera una pulsación de tecla o, si se introduce un valor, a que pase una
!! cantidad delay de décimas de segundo antes de continuar. Retorna verdadero
!! si la tecla pulsada es 'q' o 'Q', falso en caso contrario.
!!------------------------------------------------------------------------------
[ press_any_key delay char;
	#Ifdef TARGET_GLULX;
	#Ifndef NO_MULTIMEDIA;
	if (Damusix.EnFade()) delay = 0;
	#Endif; ! NO_MULTIMEDIA;
	#Endif; ! TARGET_GLULX;
	if (delay > 0) char = KeyDelay(delay);
	else char = KeyCharPrimitive();
	if (char == 'q' or 'Q') return true;
	else return false;
];

!!------------------------------------------------------------------------------
!! 
!!------------------------------------------------------------------------------
Constant NAME_BUFFER_STREAM_ID = 666;	! Cualquier stream libre.
Constant NAME_BUFFER_SIZE = 256;		! Ajustar el tamaño máximo.
Array name_buffer --> NAME_BUFFER_SIZE;

[ get_name_buffer obj
	old_stream;
	#Ifdef TARGET_GLULX;
	!! Se cambia el flujo de salida a un array de memoria:
	old_stream = glk_stream_get_current();
	glk_stream_set_current(glk_stream_open_memory(name_buffer + WORDSIZE, 
		NAME_BUFFER_SIZE, filemode_Write, NAME_BUFFER_STREAM_ID));
	!! Se escribe en el array:
	print (name) obj;
	!! Se vuelve al flujo de salida original:
	glk_stream_close(glk_stream_get_current(), gg_arguments);
	glk_stream_set_current(old_stream);
	name_buffer-->0 = gg_arguments-->1;
	#Endif; ! TARGET_GLULX;
];

[ print_name_buffer
	tmp len;
	#Ifdef TARGET_GLULX;
	len = name_buffer-->0;
	tmp = name_buffer + WORDSIZE;
	glk_put_buffer(tmp, len);
	#Endif; ! TARGET_GLULX;
];


!!==============================================================================
!!	Gramática estándar y extendida
!!------------------------------------------------------------------------------
!!	Acciones añadidas o reempazadas:
!!	 *	##Audio, ##AudioOn, ##AudioOff
!!	 *	##CloseX
!!	 *	##DefaultAction
!!	 *	##DisrobeX
!!	 *	##GNA (sólo en modo de depuración)
!!	 *	##Graphics, ##GraphicsOn, ##GraphicsOff
!!	 *	##LMode2
!!	 *	##NoSuchVerb
!!	 *	##OpenX
!!	 *	##RemarkableObjects
!!	 *	##TalkOn, ##TalkTo
!!	 *	##Teleport
!!	 *	##TopicInventory
!!	 *	##Wear
!!	 *	##WearX
!!	Acciones eliminadas:
!!	 *	##Sorry
!!	 *	##Swim
!!------------------------------------------------------------------------------

Include	"SpanishG.h";		! Gramática española
Include	"SpanishEG.h";		! Gramática española extendida

!!------------------------------------------------------------------------------
!! ##Audio, ##AudioOn, ##AudioOff
!!------------------------------------------------------------------------------
#Ifdef TARGET_GLULX;
#Ifndef NO_MULTIMEDIA;
Verb meta 'audio' 'music' 'musica' 'sonido' 'sonidos'
	*								-> Audio
	* 'on' / 'si'					-> AudioOn
	* 'encendido' / 'activado'		-> AudioOn
	* 'off' / 'no'					-> AudioOff
	* 'apagado' / 'desactivado'		-> AudioOff
;
VerboIrregular "establecer la reproducción de audio"
	with imperativo 'audio' 'music' 'musica' 'sonido' 'sonidos';

[ AudioSub;
	if (Damusix.HayAudio()) <<AudioOff>>;
	else <<AudioOn>>;
];

[ AudioOnSub;
	if (Damusix.HayAudio())
		print_ret (parser) "La reproducción de audio ya estaba activada.";
	Damusix.ActivarAudio();
	print_ret (parser) "Reproducción de audio activada.";
];

[ AudioOffSub;
	if (~~Damusix.HayAudio())
		print_ret (parser) "La reproducción de audio ya estaba desactivada.";
	Damusix.DesactivarAudio();
	print_ret (parser) "Reproducción de audio desactivada.";
];
#Endif; ! NO_MULTIMEDIA;
#Endif; ! TARGET_GLULX;

!!------------------------------------------------------------------------------
!! ##CloseX
!!------------------------------------------------------------------------------
Extend	only 'corre' replace
	* noun							-> CloseX
;

[ CloseXSub;
	print (parser) "En lugar de ~correr~ el objeto, se intenta utilizar
	la acción ~cerrar~, que en este contexto es sinónima, y es más general.
	(Apenas hay objetos corredizos en el mundo del relato, pero muchos se
	pueden abrir y cerrar.)";
	new_line; new_line;
	<<Close noun second>>;
];

!!------------------------------------------------------------------------------
!! ##DefaultAction
!!------------------------------------------------------------------------------

Verb 'no.verb'
	* noun							-> DefaultAction
;

[ DefaultActionSub;
	<<Examine noun>>;
];

!!------------------------------------------------------------------------------
!! ##DisrobeX
!! Los verbos "desnudar"/"desvestir" pueden invocarse sin indicar un objeto, de
!! manera que un objeto "clothing" pueda capturar la acción ##DisrobeX en su
!! rutina "react_before" y lanzar la acción ##Disrobe sobre sí mismo.
!!------------------------------------------------------------------------------
Verb	'desnuda' 'desviste'
	*								-> DisrobeX
	* '-te'/'-me'					-> DisrobeX
	* noun							-> DisrobeX
	* '-te'/'-me' noun				-> DisrobeX
;
VerboIrregular "desvestir" with imperativo 'desnuda' 'desviste';

[ DisrobeXSub;
	if (noun == nothing)
		print_ret (parser) "Tienes que indicar qué quieres quitarte.";
	<<Disrobe noun>>;
];

!!------------------------------------------------------------------------------
!! ##GNA (sólo en modo de depuración)
!!------------------------------------------------------------------------------
#Ifdef	DEBUG;
Verb meta 'gna'
	* multi							-> GNA
;

[ GNA g;
	g = GetGNAOfObject(noun);
	print g, ": ";
	switch (g) {
		0,1,2,3,4,5: print "animado ";
		default:	 print "inanimado ";
	}
	switch (g) {
		0,1,2,6,7,8: print "singular ";
		default:	 print "plural ";
	}
	switch (g) {
		0,3,6,9:	 print "masculino";
		1,4,7,10:	 print "femenino";
		default:	 print "neutro";
	}
];

[ GNASub;
	start_parser_style();
	print "Objeto: ";
	roman_style();
	print (name) noun;
	parser_style();
	print ". (", (The) noun," / ", (the) noun," / ", (a) noun,
	" / -", (o) noun, ")^GNA ", (GNA) noun;
	end_parser_style();
	new_line;
];
#Endif; ! DEBUG;

!!------------------------------------------------------------------------------
!! ##Graphics, ##GraphicsOn, ##GraphicsOff
!!------------------------------------------------------------------------------
#Ifdef TARGET_GLULX;
#Ifndef NO_MULTIMEDIA;
Verb meta 'grafico' 'graficos' 'graphic' 'graphics'
	*								-> Graphics
	* 'on'/'si'						-> GraphicsOn
	* 'encendido'/'activado'		-> GraphicsOn
	* 'encendidos'/'activados'		-> GraphicsOn
	* 'off'/'no'					-> GraphicsOff
	* 'apagado'/'desactivado'		-> GraphicsOff
	* 'apagados'/'desactivados'		-> GraphicsOff
;
VerboIrregular "establecer ventana gráfica"
	with imperativo 'grafico' 'graficos' 'graphic' 'graphics';

!! FIXME - Cuando se cierra la ventana y se abre después, la imágen que se
!! mostraba deja de hacerlo.

[ GraphicsSub;
	if (GRAPHIC_WIN_FLAG) <<GraphicsOff>>;
	else <<GraphicsOn>>;
];

[ GraphicsOnSub;
	if (GRAPHIC_WIN_FLAG)
		print_ret (parser) "La ventana gráfica ya estaba abierta.";
	ShowGraphicWindow();
	print_ret (parser) "Ventana gráfica abierta.";
];

[ GraphicsOffSub;
	if (~~GRAPHIC_WIN_FLAG)
		print_ret (parser) "La ventana gráfica ya estaba cerrada.";
	HideGraphicWindow();
	print_ret (parser) "Ventana gráfica cerrada.";
];
#Endif; ! NO_MULTIMEDIA;
#Endif; ! TARGET_GLULX;

!!------------------------------------------------------------------------------
!! ##LMode2
!!------------------------------------------------------------------------------
Extend only 'normal' replace
    *								-> LMode2
;

!!------------------------------------------------------------------------------
!! ##NoSuchVerb
!! Permite eliminar acciones definidas automáticamente por la librería Inform.
!! Código extraído de <http://www.firthworks.com/roger/informfaq/vv.html#6>.
!!------------------------------------------------------------------------------
[ Anything; ! Ignore the remaining input line
	while (NextWordStopped() ~= -1);
	return GPR_PREPOSITION;
];

[ NoSuchVerbSub; return ParserError(VERB_PE); ];

Extend	'perdona' replace
	* Anything						-> NoSuchVerb
;

Extend	'nada' replace
	* Anything						-> NoSuchVerb
;

!!------------------------------------------------------------------------------
!! ##OpenX
!!------------------------------------------------------------------------------
Verb	'descorre'
	* noun							-> OpenX
;

[ OpenXSub;
	print (parser) "En lugar de ~descorrer~ el objeto, se intenta utilizar
	la acción ~abrir~, que en este contexto es sinónima, y es más general.
	(Apenas hay objetos corredizos en el mundo del relato, pero muchos se
	pueden abrir y cerrar.)";
	new_line; new_line;
	<<Open noun second>>;
];

!!------------------------------------------------------------------------------
!! ##RemarkableObjects
!!------------------------------------------------------------------------------
Verb	meta 'objetos' 'objs'
	*								-> RemarkableObjects
;
VerboIrregular "mostrar objetos clave" with imperativo 'objetos' 'objs';

Global remarkableObjectsCount;
[ CountRemarkableObjects obj;
	if (obj has remarkable) remarkableObjectsCount++;
];
[ PrintRemarkableObjects obj;
	if (obj has remarkable) {
		PronounNotice(obj);
		print " ", (the) obj;
		remarkableObjectsCount--;
		if (remarkableObjectsCount > 1) print ",";
		else if (remarkableObjectsCount == 1) print " y";
	}
];

[ RemarkableObjectsSub;
	remarkableObjectsCount = 0;
	LoopOverScope(CountRemarkableObjects);
	if (remarkableObjectsCount == 0)
		print_ret (parser) "No hay objetos destacables con los que puedas
		interactuar.";
	start_parser_style();
	print "Puedes interactuar con";
	LoopOverScope(PrintRemarkableObjects);
	print ".";
	end_parser_style();
	new_line;
	return true;
];

!!------------------------------------------------------------------------------
!! ##TalkOn, ##TalkTo
!!------------------------------------------------------------------------------
Extend	'habla' replace
	* noun							-> TalkTo
	* 'a'/'con' noun				-> TalkTo
	* creature						-> TalkTo
	* 'a'/'con' creature			-> TalkTo
	* 'por' noun					-> TalkOn
	* 'por' creature				-> TalkOn
;

Verb	'conversa' 'platica'
	* noun							-> TalkTo
	* 'a'/'con' noun				-> TalkTo
	* creature						-> TalkTo
	* 'a'/'con' creature			-> TalkTo
	* 'por' noun					-> TalkOn
	* 'por' creature				-> TalkOn
;

[ TalkOnSub;
	start_parser_style();
	print "Habla con ", (name) noun;
	end_parser_style();
	new_line;
	<<TalkTo noun second>>;
];

[ TalkToSub;
	if ( noun == player ) {
		switch (GRAMMATICAL_INFLECTION) {
		1,2,3:	"Hablar con uno mismo no resulta especialmente divertido.";
		4,5,6:	"Hablar con uno mismo no resultaba especialmente divertido.";
		}
	}
	if ( noun hasnt animate )
		switch (GRAMMATICAL_INFLECTION) {
		1,2,3:	"Mejor intentar hablar con cosas que puedan devolver
				una respuesta.";
		4,5,6:	"Mejor intentar hablar con cosas que pudiesen devolver
				una respuesta.";
	}
	switch (GRAMMATICAL_INFLECTION) {
	1:	print_ret (The) noun, " no parece", (n) noun, " estar interesad",
		(o) noun, " en hablar conmigo.";
	2:	print_ret (The) noun, " no parece", (n) noun, " estar interesad",
		(o) noun, " en hablar contigo.";
	3:	print (The) noun, " no parece", (n) noun, " estar interesad",
		(o) noun, " en hablar con ";
		if (player has female ||
			(player provides gender && player.gender == G_FEMENINO))
			print "ella";
		else
			print "él";
		".";
	4:	print_ret (The) noun, " no parecía", (n) noun, " estar interesad",
		(o) noun, " en hablar conmigo.";
	5:	print_ret (The) noun, " no parecía", (n) noun, " estar interesad",
		(o) noun, " en hablar contigo.";
	6:	print (The) noun, " no parecía", (n) noun, " estar interesad",
		(o) noun, " en hablar con ";
		if (player has female ||
			(player provides gender && player.gender == G_FEMENINO))
			print "ella";
		else
			print "él";
		".";
	}
];

!!------------------------------------------------------------------------------
!! ##Teleport
!!------------------------------------------------------------------------------

[ TeleportScope obj adjacent_location;
	switch (scope_stage) {
		1:	return false;
		2:	objectloop (obj in Compass) {
				adjacent_location = real_location.(obj.door_dir);
				if (adjacent_location ~= 0)
					PlaceInScope(adjacent_location);
			}
			return true;
		3:	print_ret (parser) "No puedes llegar hasta ahí desde donde estás en 
			estos momentos.";
	}
];

Extend 've' last
	* scope=TeleportScope			-> Teleport
	* 'a//' scope=TeleportScope		-> Teleport
	* 'hacia' scope=TeleportScope	-> Teleport
;

Extend 'entra' last
	* scope=TeleportScope			-> Teleport
	* 'a//' scope=TeleportScope		-> Teleport
	* 'en' scope=TeleportScope		-> Teleport
;

Verb 'teleport.verb'
	* scope=TeleportScope			-> Teleport
;

[ TeleportSub;
	PlayerTo(noun, 2);
];

!!------------------------------------------------------------------------------
!! ##TopicInventory
!!------------------------------------------------------------------------------
Verb	meta 'temas' 't//'
	*								-> TopicInventory
;
VerboIrregular "mostrar inventario de temas" with imperativo 'temas' 't//';

[ TopicInventorySub;
	if (~~(ConversationManager.is_running()))
		print_ret (parser) "No hay conversaciones activas en este momento.";
	ConversationManager.show_topic_inventory(true);
];

!!------------------------------------------------------------------------------
!! ##Wear
!! Basada en la implementación de *verblibm.h*. Si el objeto no está en
!! posesión del jugador, se le intenta pasar a su inventario automáticamente.
!!------------------------------------------------------------------------------
Extend	'ponte' replace
	* noun							-> Wear
	* 'con' noun					-> Wear
;

[ WearSub;
	if (ObjectIsUntouchable(noun)) return;
	if (noun hasnt clothing)    return L__M(##Wear, 1, noun);
	if (parent(noun) ~= player)
		if (AttemptToTakeObject(noun))
			return true;
	if (noun has worn)          return L__M(##Wear, 3, noun);
	give noun worn;
	if (AfterRoutines() == 1) rtrue;
	if (keep_silent == 1) rtrue;
	L__M(##Wear, 4, noun);
];

!!------------------------------------------------------------------------------
!! ##WearX
!! El verbo "vestir" ('vistete', 'vestirse', 'vestirte'...) puede invocarse sin
!! indicar un objeto, de manera que un objeto "clothing" pueda capturar la
!! acción ##WearX en su rutina "react_before" y lanzar la acción ##Wear sobre
!! sí mismo.
!!------------------------------------------------------------------------------
Extend	only 'vistete' 'vestirse' 'vestirte' 'vestirme' 'visteme' replace
	*								-> WearX
	* noun							-> WearX
	* 'con' noun					-> WearX
;
VerboIrregular "vestir" with imperativo
	'vistete' 'vestirse' 'vestirte' 'vestirme' 'visteme';

[ WearXSub;
	if (noun == nothing)
		print_ret (parser) "Tienes que indicar con qué quieres vestirte.";
	<<Wear noun>>;
];


!!==============================================================================
!!	Definición de atributos, clases y objetos
!!------------------------------------------------------------------------------

Include ">59mins_classes.inf";
Include ">59mins_objects.inf";
Include ">59mins_objects2.inf";


